import{r as I}from"./index-MfwDCBrI.js";const A="",C=3e4,U=3,q=1e3;class d extends Error{constructor(e,t,r,i){super(e),this.statusCode=t,this.code=r,this.data=i,this.name="ApiError"}}class y extends d{constructor(e,t){super(e,void 0,"NETWORK_ERROR",t),this.name="NetworkError"}}class m extends d{constructor(e="Request timeout"){super(e,void 0,"TIMEOUT_ERROR"),this.name="TimeoutError"}}class O{constructor(e=""){this.requestInterceptors=[],this.responseInterceptors=[],this.errorInterceptors=[],this.baseUrl=e}addRequestInterceptor(e){this.requestInterceptors.push(e)}addResponseInterceptor(e){this.responseInterceptors.push(e)}addErrorInterceptor(e){this.errorInterceptors.push(e)}buildUrl(e){if(e.startsWith("http://")||e.startsWith("https://"))return e;if(!this.baseUrl)return e.startsWith("/")?e:`/${e}`;const t=this.baseUrl.endsWith("/")?this.baseUrl.slice(0,-1):this.baseUrl,r=e.startsWith("/")?e:`/${e}`;return`${t}${r}`}async applyRequestInterceptors(e){let t={...e};for(const r of this.requestInterceptors)t=await r(t);return t}async applyResponseInterceptors(e,t){let r=t;for(const i of this.responseInterceptors)r=await i(e,r);return r}async applyErrorInterceptors(e){let t=e;for(const r of this.errorInterceptors)t=await r(t);return t}createAbortController(e){const t=new AbortController,r=setTimeout(()=>t.abort(),e);return t.signal.addEventListener("abort",()=>clearTimeout(r)),t}async handleResponse(e){if(!e.ok){let o=`Server error (${e.status})`,n={};try{e.headers.get("content-type")?.includes("application/json")?(n=await e.json(),o=n.message||n.error||o):o=e.statusText||o}catch{o=e.statusText||o}throw e.status===400?o=n.message||"Invalid request. Please check your inputs.":e.status===401?o="Authentication required. Please connect your wallet.":e.status===403?o=n.message||"Permission denied. You don't have access to perform this action.":e.status===404?o="Endpoint not found. Please refresh the page.":e.status===429?o="Too many requests. Please wait a moment and try again.":e.status>=500&&(o=n.message||"Server error. Our team has been notified. Please try again later."),new d(o,e.status,n.errorCode||`HTTP_${e.status}`,n)}if(e.headers.get("content-type")?.includes("application/json")){const o=await e.json(),n=await this.applyResponseInterceptors(e,o);return n&&typeof n=="object"&&"success"in n?n:{success:!0,data:n}}const r=await e.text();return{success:!0,data:await this.applyResponseInterceptors(e,r)}}async request(e,t={}){const{timeout:r=C,retry:i,headers:o,...n}=t,u=await this.applyRequestInterceptors(t),g=this.buildUrl(e),l=new Headers(o);u.headers&&(u.headers instanceof Headers?u.headers.forEach((s,c)=>{l.set(c,s)}):Array.isArray(u.headers)?u.headers.forEach(([s,c])=>{l.set(s,c)}):Object.entries(u.headers).forEach(([s,c])=>{c&&l.set(s,String(c))})),!l.has("Content-Type")&&n.body&&l.set("Content-Type","application/json");const{headers:v,timeout:P,retry:_,skipAuth:k,...E}=u,w={...E,...n,headers:l},T=this.createAbortController(r),h=async()=>{try{const s=await fetch(g,{...w,signal:T.signal});return await this.handleResponse(s)}catch(s){throw s instanceof Error&&s.name==="AbortError"?new m(`Request timeout after ${r}ms`):s instanceof TypeError&&s.message.includes("fetch")?new y("Unable to connect to server. Please check your internet connection.",s):s instanceof d?s:new d(s instanceof Error?s.message:"Unknown error occurred",void 0,"UNKNOWN_ERROR",s)}},f=i?.attempts??U,b=i?.delay??q,R=i?.retryableStatusCodes??[408,429,500,502,503,504];try{return f>1?await I(h,{maxRetries:f-1,retryDelay:b,maxDelay:1e4,backoffMultiplier:2,retryable:s=>s instanceof d&&s.statusCode?R.includes(s.statusCode):s instanceof y||s instanceof m}):await h()}catch(s){const c=s instanceof d?s:new d(s instanceof Error?s.message:"Unknown error occurred",void 0,"UNKNOWN_ERROR",s);throw await this.applyErrorInterceptors(c)}}async get(e,t){return this.request(e,{...t,method:"GET"})}async post(e,t,r){return this.request(e,{...r,method:"POST",body:t?JSON.stringify(t):void 0})}async put(e,t,r){return this.request(e,{...r,method:"PUT",body:t?JSON.stringify(t):void 0})}async patch(e,t,r){return this.request(e,{...r,method:"PATCH",body:t?JSON.stringify(t):void 0})}async delete(e,t){return this.request(e,{...t,method:"DELETE"})}}const p=new O(A);p.addErrorInterceptor(a=>(console.error("[API Error]",{message:a.message,statusCode:a.statusCode,code:a.code,data:a.data}),a));async function S(){const a=await p.get("/api/v1/analytics/platform");return a.success?{success:!0,data:a.data}:{success:!1,error:a.error||"Failed to get platform analytics"}}async function $(a){const e=await p.get(`/api/v1/analytics/user/${a}`);return e.success?{success:!0,data:e.data}:{success:!1,error:e.error||"Failed to get user analytics"}}async function D(a=20){const e=await p.get(`/api/v1/feed?limit=${a}`);return e.success?{success:!0,data:e.data}:{success:!1,error:e.error||"Failed to get tip feed"}}async function F(a){const e=await p.get(`/api/v1/badges/user/${a}`);return e.success?{success:!0,data:e.data}:{success:!1,error:e.error||"Failed to get user badges"}}async function W(a){const e=await p.post("/api/v1/badges/check",{userId:a});return e.success?{success:!0,data:e.data}:{success:!1,error:e.error||"Failed to check badges"}}export{d as ApiError,y as NetworkError,m as TimeoutError,p as apiClient,W as checkBadges,S as getPlatformAnalytics,D as getTipFeed,$ as getUserAnalytics,F as getUserBadges};
